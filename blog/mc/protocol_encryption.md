# Minecraft protocol encryption (pvn 47)

***Note:** I've tested this on pvn 47 but i'm pretty sure this will work on all versions.*

I have been making a minecraft server written in typescript (for 1.8 or pvn 47) with as little libraries / packages as possible. This is about how to implement the encryption part of the protocol. The example code is in typescript.

If you are trying to follow a long, this article expects you have implemented the basic protocol packet reading and writing (See [Links](#links))

## How encryption is enabled
The following packets are sent to enable encryption:

**S** -> **C**: [Encryption Request](#encryption-request-packet)\
*Client authentication*\
**C** -> **S**: [Encryption Response](#encryption-response-packet)\
*Server authentication*

After the [Encryption Response](#encryption-response-packet) packet is recieved and the server authenticates the user with mojang, the following packets are sent using a AES/CFB8 cipher (See [Encrypting packets](#encrypting-packets))

## Encryption request packet

The Encryption request packet is sent once the Login start packet is received:

| Field Name | Field Type | Notes |
| --- | --- | --- | 
| Server ID	| String | This is a empty string
| Public key length | VarInt | Length of the public key
| Public Key | Byte Array | This is the 1024-Bit RSA public key
| Verify Token Length | VarInt | Length of the verify token
| Verify Token | Byte Array | Random bytes to confirm encryption

- `Server ID`: This field is empty, it was used in older versions of the protocol
- `Public Key`: This is a 1024-Bit RSA public key:\
  *(There is probably a better way to do this but it works :shrug:)*
  ```ts
  // Generate keys
  const keys = crypto.generateKeyPairSync("rsa", {
    modulusLength: 1024
  })

  // Function to get the bytes from the key
  function getKeyBytes(publicKey: crypto.KeyObject): Buffer {
    // Convert the key to a string
    const keyString = publicKey.export({
      type: "spki",
      format: "pem",
    }).toString()

    // Remove the headers
    const keyNoHeaders = keyString
      .replace('-----BEGIN PUBLIC KEY-----\n', '')
      .replace('\n-----END PUBLIC KEY-----\n', '');
      
    // Base64 decode the remaining data
    const keyBytes = Buffer.from(keyNoHeaders, "base64")
    return keyBytes
  }

  const keyBytes = getKeyBytes(keys.publicKey)
  ```
  - `Verify Token`: This is some random bytes that is used later to confirm the encryption has worked correctly:
  ```ts
  const verifyToken = crypto.randomBytes(32)
  connection.verifyToken = verifyToken
  // Used later in encryption response packet
  ```

Now write the packet to the client and wait for the encryption response.

# Encryption response packet
After you have sent the encryption request packet the client will do some requests to mojang and respond with the following encryption response packet:

| Field Name | Field Type | Notes |
| --- | --- | --- | 
| Shared Secret Length | VarInt | Length of Shared Secret.
| Shared Secret | Byte Array | 16 random bytes generated by client, encrypted by the public key
| Verify Token Length | VarInt | Length of Shared Secret.
| Verify Token | Byte Array | This is the encrypted verify token from the [Encryption request packet](#encryption-request-packet)


1. First you should decrypt your shared secret and your verify token with your public key:\
    (Note: The values are padded using PKCS#1 v1.5)
    ```ts
    function decrypt(buffer: Buffer): Buffer {
      return crypto.privateDecrypt({
        key: keys.privateKey, // Replace with your private key
        padding: 1 // PKCS#1 v1.5 padding
      }, buffer)
    }

    const decryptedSecret = decrypt(packet.sharedSecret)
    const decryptedToken = decrypt(packet.verifyToken)
    ```

    Next you should confirm the token is the same as the one you sent:
    ```ts
    if (!decryptedToken.equals(connection.verifyToken)) {
      connection.disconnect("Verify token encrypted incorrectly.")
      return
    }
    ```

    After that we should save our shared secret:
    ```ts
    connection.sharedSecret = decryptedSecret
    ```

2. Next we need to make a `HTTP GET` request to `https://sessionserver.mojang.com/session/minecraft/hasJoined?username=USERNAME&serverId=HASH`

    The following parameters are passed in the GET request:
    - `username`: This is the name sent in the Login start packet
    - `hash`: This is the servers hash, it is a `sha1` hash that updates with the `serverId (empty)`, `sharedSecret`, `publicKey`
      ```ts
      const hash = crypto.createHash("sha1")
          .update("")
          .update(connection.sharedSecret)
          .update(getKeyBytes(connection.keys.publicKey))
          .digest()
      ```
      After creating our hash we need to convert it to hex string. This is not a standard method and is a custom method by mojang. You should see the [wiki](https://wiki.vg/Protocol_Encryption#Authentication) for more infomation about this.
      ```ts
      // This code is from https://gist.github.com/andrewrk/4425843
      let negative = hash.readInt8(0) < 0
      if (negative) performTwosCompliment(hash)
      let digest = hash.toString('hex')
      // trim leading zeroes
      digest = digest.replace(/^0+/g, '')
      if (negative) digest = '-' + digest
      return digest

      function performTwosCompliment(buffer: Buffer) {
        let carry = true;
        let i, newByte, value;
        for (let i = buffer.length - 1; i >= 0; --i) {
          value = buffer.readUInt8(i)
          newByte = ~value & 0xff
          if (carry) {
            carry = newByte === 0xff
            buffer.writeUInt8(carry ? 0 : newByte + 1, i)
          } else {
            buffer.writeUInt8(newByte, i)
          }
        }
      }
      ```

3. After sending the correct `username` and `hash` you should have a response. If you get `204 No Content` you have either done something wrong or the user is not authenticated with mojang.

    If the user is authenticated with mojang and your hash is correct you will get a response like this:
    ```json
    {
      "id": "<Player UUID>",
      "name": "<Player Username>",
      "properties": [ 
        {
          "name": "textures",
          "value": "<base64 string>",
          "signature": "<base64 string>"
        }
      ]
    }
    ```
    You can use the `id` and `name` from this object for the player infomation.

You have now enabled encryption for both client and server.

## Encrypting packets

Now that you have enabled encryption you can start sending encrypted packets. Although it is called encryption we are actually using a `AES/CFB8 cipher`.

Before you send a packet you will need to use a cipher to encrypt it:

- This cipher is created once and will be updated for each packet.
- The ciphers `key` and `iv` are both the `sharedSecret` (from [Encryption Response](#encryption-response-packet))

*(Note: The entire packet is ciphered, including length, packet id, data, and anything else)*

```ts
function flush() {
  // this.writerBuffer is an array I write to, you do not need to worry about
  let buffer = Buffer.from(this.writeBuffer)
  // If encryption is enabled we can modify the buffer with the AES cipher
  if (this.isEncryption()) {
    buffer = this.cipherEncrypt(buffer)
  }
  // Write and reset buffer
  this.socket.write(buffer)
  this.writeBuffer = []
}

function cipherEncrypt(buffer: Buffer): Buffer {
  if (!this.isEncryption()) throw new Error("Encryption not enabled")
  // The cipher is not recreated each time, if it does not exist create it with the sharedSecret
  if (!cipher) {
    cipher = crypto.createCipheriv("aes-128-cfb8", sharedSecret, sharedSecret)
  }
  // Now with the created cipher or the existing cipher we update it with the packet data
  return cipher.update(buffer)
}
```
And that's it for encrypting packets, you can now write to the `writerBuffer` and when `flush()` is called it will encrypt the buffer and send it. *(You should implement this with your own system, this is just for my server)*

## Decrypting packets

Decrypting packets are quite simple, when your server receive a byte you decipher it.

The decipher is created the same as the cipher ([Encrpyting packets](#encrypting-packets)) with the `key` and `iv` both being the `sharedSecret`

```ts
function readByteFromBuffer(): number {
  // Read byte and remove it
  let byte = this.dataBuffer.shift()
  if (byte == undefined) throw new Error("No data in buffer.")
  if (this.isEncryption()) {
    // Convert the byte to a buffer, then with the buffer returned get the first byte
    byte = this.cipherDecrypt(Buffer.from([byte]))[0]
  }
  return byte
}

function cipherDecrypt(buffer: Buffer): Buffer {
  if (!this.isEncryption()) throw new Error("Encryption not enabled")

  if (!decipher) {
    decipher = crypto.createDecipheriv("aes-128-cfb8", this.sharedSecret, this.sharedSecret)
  }

  return decipher.update(buffer)
}
```


## Sources & References  
- [wiki.vg - Protocol 47](https://wiki.vg/index.php?title=Protocal&oldid=7407)
- [wiki.vg - Protocol encryption](https://wiki.vg/Protocol_Encryption)
- [git gist - Server hash in nodejs](https://gist.github.com/andrewrk/4425843)